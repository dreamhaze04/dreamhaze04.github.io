<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ABC386-F-Operate-K</title>
    <url>/2025/01/21/13/51/54/</url>
    <content><![CDATA[<p>这题在编辑距离的基础上限制了操作步骤，这题的字符串长度在 5e5,
用常规的编辑距离的方法，时空复杂度均为O(mn)，必超时加MLE，所以需要一定的优化。分析可知，dp矩阵只有中间一部分有贡献，其他的部分（i
- j &gt; k）中，必然无法在 k 次处理中完成，故可以舍去，因此我们只需要用
<code>dp[n + 1][2K + 1]</code> 的数组就可以完成任务，然后通过自定义的
get_dp 与 set_dp 方法即可联系常规 dp 到 变化后 dp 的关系</p>
<span id="more"></span>
<h1 id="f---operate-k"><a
href="https://atcoder.jp/contests/abc386/tasks/abc386_f">F - Operate
K</a></h1>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>); cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k; cin &gt;&gt; k;</span><br><span class="line">    string s, t; cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">size</span>(), m = t.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, vector&lt;<span class="type">int</span>&gt;(<span class="number">2</span> * k + <span class="number">1</span>, inf))</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> get_dp = [&amp;](<span class="type">int</span> i, <span class="type">int</span> j) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(i - j) &gt; k) <span class="keyword">return</span> inf;</span><br><span class="line">        <span class="keyword">return</span> dp[i][j - i + k];</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> set_dp = [&amp;](<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> x) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(i - j) &gt; k) <span class="keyword">return</span>;</span><br><span class="line">        dp[i][j - i + k] = x;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">set_dp</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">min</span>(m, k); ++ i)&#123;</span><br><span class="line">        <span class="built_in">set_dp</span>(<span class="number">0</span>, i, i);</span><br><span class="line">    &#125;<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">min</span>(n, k); ++ i)&#123;</span><br><span class="line">        <span class="built_in">set_dp</span>(<span class="number">0</span>, i, i);</span><br><span class="line">        <span class="built_in">set_dp</span>(i, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> d = <span class="number">0</span>; d &lt;= <span class="number">2</span> * k; ++ d) &#123;</span><br><span class="line">            <span class="type">int</span> j = i - k + d;</span><br><span class="line">            <span class="keyword">if</span> (j &lt;= <span class="number">0</span> || j &gt; m) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (s[i - <span class="number">1</span>] == t[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="built_in">set_dp</span>(i, j, <span class="built_in">get_dp</span>(i - <span class="number">1</span>, j - <span class="number">1</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">set_dp</span>(i, j, <span class="built_in">min</span>(&#123;<span class="built_in">get_dp</span>(i - <span class="number">1</span>, j - <span class="number">1</span>), <span class="built_in">get_dp</span>(i - <span class="number">1</span>, j), <span class="built_in">get_dp</span>(i, j - <span class="number">1</span>)&#125;) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; (<span class="built_in">get_dp</span>(n, m) &lt;= k ? <span class="string">&quot;Yes\n&quot;</span> : <span class="string">&quot;No\n&quot;</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>编辑距离</tag>
      </tags>
  </entry>
  <entry>
    <title>解决 neovide 的部分图标缺失问题</title>
    <url>/2025/01/23/07/01/40/</url>
    <content><![CDATA[<p>由于默认 neovide
字体图标不全导致部分图标以<strong>小飞船</strong>的形式出现，我们可以通过下载
Nerd Font 字体来解决这个问题。</p>
<span id="more"></span>
<h1 id="乱码展示">乱码展示</h1>
<p>以下为乱码，可以看到都是以小飞船的图标展示</p>
<p><img src="https://s2.loli.net/2025/01/23/5ZUGnpuSYiRk1lW.png" /></p>
<p>以下为修复后的，所有字体都正常，并且保留了连字功能</p>
<p><img src="https://s2.loli.net/2025/01/23/BMdXxDhgKiO2sW6.png" /></p>
<h1 id="下载字体">下载字体</h1>
<p>前往 <span class="exturl" data-url="aHR0cHM6Ly93d3cubmVyZGZvbnRzLmNvbS9mb250LWRvd25sb2Fkcw==">Nerd Font
官网的下载页面<i class="fa fa-external-link-alt"></i></span>，找到 FiraCode Nerd Font
字体（该字体支持连字）下载。</p>
<p><img src="https://s2.loli.net/2025/01/23/XPDBTsGlf57cAKS.png" /></p>
<p>下载后解压文件，全选右键安装</p>
<p><img src="https://s2.loli.net/2025/01/23/bwJUmuHAflKzjxe.png" /></p>
<h1 id="配置neovim">配置neovim</h1>
<p>在 neovim 的配置文件中加入这段代码来设置 neovide
字体，重启即可生效</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> vim.g.neovide <span class="keyword">then</span> <span class="comment">-- 只对 neovide 起作用</span></span><br><span class="line">    vim.o.guifont = <span class="string">&quot;FiraCode Nerd Font:h14&quot;</span> <span class="comment">-- text below applies for VimScript</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>neovim</tag>
        <tag>neovide</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P1433-吃奶酪</title>
    <url>/2025/01/20/05/58/12/</url>
    <content><![CDATA[<p>这道题在新手题单里面卡了我两个月，原因就是这道题出现在了搜索的板块，但是正规做法是用状态压缩dp来做，于是我就一直搁着，最近算是终于给他解决了，其实这道题本质是和<a href="/2025/01/23/00/35/23/" title="最短Hamilton距离">最短Hamilton距离</a>完全一样，就最后一步有点变化。</p>
<span id="more"></span>
<h1 id="吃奶酪"><a
href="https://www.luogu.com.cn/problem/P1433">吃奶酪</a></h1>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">17</span>;</span><br><span class="line"><span class="type">double</span> dp[<span class="number">1</span>&lt;&lt;N][N];</span><br><span class="line"><span class="type">double</span> dis[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>); cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x7f</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="type">int</span> n; cin &gt;&gt; n; ++n;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt;&gt; <span class="built_in">a</span>(n<span class="number">+1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i) &#123;</span><br><span class="line">        cin &gt;&gt; a[i].first &gt;&gt; a[i].second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j) &#123;</span><br><span class="line">            dis[i][j] = <span class="built_in">hypot</span>(a[i].first - a[j].first, a[i].second - a[j].second);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> s=<span class="number">1</span>;s&lt;(<span class="number">1</span>&lt;&lt;n);++s) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((s &gt;&gt; i) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((s^(<span class="number">1</span>&lt;&lt;i)) &gt;&gt; j &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                        dp[s][i] = <span class="built_in">min</span>(dp[s][i], dp[s^(<span class="number">1</span>&lt;&lt;i)][j] + dis[j][i]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> ans = INFINITY;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i) &#123;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, dp[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title>拓扑排序</title>
    <url>/2025/01/21/08/19/03/</url>
    <content><![CDATA[<p>在不保证字典序的时候可以使用 dfs 或者
kahn(基于bfs)，当需要满足字典序时可用优先队列维护</p>
<span id="more"></span>
<h1 id="拓扑排序">拓扑排序</h1>
<h2 id="kahn">Kahn</h2>
<p>例题：<a
href="https://vjudge.net/problem/HDU-1285">确定比赛名次</a></p>
<h3 id="代码">代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>); cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; m) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adj</span>(n);</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">degree</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (m --) &#123;</span><br><span class="line">            <span class="type">int</span> u, v; cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">            -- u, -- v;</span><br><span class="line">            adj[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">            degree[v] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;&gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!degree[i]) q.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> x = q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            ans.<span class="built_in">push_back</span>(x);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> y : adj[x]) &#123;</span><br><span class="line">                -- degree[y];</span><br><span class="line">                <span class="keyword">if</span> (!degree[y]) &#123;</span><br><span class="line">					q.<span class="built_in">push</span>(y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ans.<span class="built_in">size</span>(); ++ i) &#123;</span><br><span class="line">            cout &lt;&lt; ans[i] + <span class="number">1</span> &lt;&lt; <span class="string">&quot; \n&quot;</span>[i == (<span class="type">int</span>)ans.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="利用拓扑排序判断连通性">利用拓扑排序判断连通性</h2>
<p><img src="https://s2.loli.net/2025/01/21/Vl4cz2pIdvoOyTg.png" /></p>
<p>例题：<span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9wcm9ibGVtc2V0L3Byb2JsZW0vMTkzMS9G">Chat
Screenshots<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="代码-1">代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, K; cin &gt;&gt; n &gt;&gt; K;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adj</span>(n);</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">degree</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (K --) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">            -- a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; ++ i) &#123;</span><br><span class="line">            adj[a[i]].<span class="built_in">push_back</span>(a[i + <span class="number">1</span>]);</span><br><span class="line">            degree[a[i + <span class="number">1</span>]] ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!degree[i]) q.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        ++ cnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v : adj[u]) &#123;</span><br><span class="line">            -- degree[v];</span><br><span class="line">            <span class="keyword">if</span> (!degree[v]) q.<span class="built_in">push</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt == n) cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>); cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t; cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123; <span class="built_in">solve</span>(); &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="求解拓扑的深度">求解拓扑的深度</h2>
<h3 id="例题车站分级">例题：<a
href="https://www.luogu.com.cn/problem/P1983">车站分级</a></h3>
<h4 id="收获">收获</h4>
<ul>
<li>这题首先是没有用邻接矩阵来判断重边，导致我用邻接表一直塞重边，然后就
MLE 了</li>
<li>然后就是我用了 dfs
来求深度，然后没有判重，但是我觉得不能判重，因为之后的答案和当前状态有关，但是我又懒得写记忆化搜索。然而实际上用
BFS 就能完美解决。</li>
</ul>
<h4 id="代码-2">代码</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>); cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n, m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adj</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">deg</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">vector <span class="title">G</span><span class="params">(n + <span class="number">1</span>, vector&lt;<span class="type">bool</span>&gt;(n + <span class="number">1</span>))</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (m --) &#123;</span><br><span class="line">        <span class="type">int</span> s; cin &gt;&gt; s;</span><br><span class="line">        <span class="type">int</span> minn = <span class="number">1e9</span>, maxn = <span class="number">0</span>;</span><br><span class="line">        set&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(s)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s; ++ i) &#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">            minn = <span class="built_in">min</span>(minn, a[i]);</span><br><span class="line">            maxn = <span class="built_in">max</span>(maxn, a[i]);</span><br><span class="line">            st.<span class="built_in">insert</span>(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = minn; i &lt;= maxn; ++ i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!st.<span class="built_in">count</span>(i)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> v : a) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!G[i][v]) &#123;</span><br><span class="line">                        adj[i].<span class="built_in">push_back</span>(v);</span><br><span class="line">                        deg[v] ++;</span><br><span class="line">                        G[i][v] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!deg[i]) &#123;</span><br><span class="line">            q.<span class="built_in">emplace</span>(i, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [u, d] = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v : adj[u]) &#123;</span><br><span class="line">            deg[v] --;</span><br><span class="line">            <span class="keyword">if</span> (!deg[v]) &#123;</span><br><span class="line">                q.<span class="built_in">emplace</span>(v, d + <span class="number">1</span>);</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, d + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>排列中的循环问题</title>
    <url>/2025/01/21/12/07/10/</url>
    <content><![CDATA[<p>该类问题通常通过一个排列中的一个元素作为索引指向排列中的另外一个元素，这样通常能够构成一个循环</p>
<p>例如一个排列 <span class="math inline">\(P  = [2, 3, 1, 5,
4]\)</span></p>
<p>有循环 <span class="math inline">\(2 \rightarrow 3 \rightarrow 1
\rightarrow 2\)</span> 和 <span class="math inline">\(4 \rightarrow 5
\rightarrow 4\)</span></p>
<span id="more"></span>
<h1 id="例题">例题</h1>
<h2 id="sakurako-kosuke-and-the-permutation"><a
href="https://codeforces.com/contest/2033/problem/E">Sakurako, Kosuke,
and the Permutation</a></h2>
<h3 id="思路">思路</h3>
<p>通过题意可知，题目定义的简单的排列是一个排列中循环的长度不大于 2
，因此只需要遍历每个元素找到循环，对于大于 2 的循环做一次统计，
不难发现，只需要对长度大于 2 的排列执行 <span class="math inline">\((len
- 1) / 2\)</span> 次操作即可将排列拆分为小于 2 的循环</p>
<h3 id="代码">代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        cin &gt;&gt; p[i];</span><br><span class="line">        -- p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">vis</span><span class="params">(n)</span></span>;</span><br><span class="line">    i64 ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="type">int</span> x = i;</span><br><span class="line">        <span class="keyword">if</span> (!vis[x]) &#123;</span><br><span class="line">            vis[x] = <span class="literal">true</span>;</span><br><span class="line">            <span class="type">int</span> len = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (!vis[p[x]]) &#123;</span><br><span class="line">                vis[p[x]] = <span class="literal">true</span>;</span><br><span class="line">                x = p[x];</span><br><span class="line">                ++ len;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (len &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                ans += (len - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>); cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t; cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123; <span class="built_in">solve</span>(); &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排列</tag>
      </tags>
  </entry>
  <entry>
    <title>最小生成树模板</title>
    <url>/2025/01/21/12/18/51/</url>
    <content><![CDATA[<p>最常用的两个最小生成树算法是 Prim 和
Kruskal。前者编码较为复杂，用优先队列来维护；后者编码较容易，用并查集来维护。</p>
<span id="more"></span>
<h1 id="prim">Prim</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>); cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n, m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;vector&lt;pair&lt;<span class="type">int</span>, i64&gt;&gt;&gt; <span class="built_in">adj</span>(n);</span><br><span class="line">    <span class="keyword">while</span> (m --) &#123;</span><br><span class="line">        <span class="type">int</span> u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        -- u, -- v;</span><br><span class="line">        adj[u].<span class="built_in">emplace_back</span>(v, w);</span><br><span class="line">        adj[v].<span class="built_in">emplace_back</span>(u, w);</span><br><span class="line">    &#125;</span><br><span class="line">    priority_queue&lt;pair&lt;i64, <span class="type">int</span>&gt;, vector&lt;pair&lt;i64, <span class="type">int</span>&gt;&gt;, greater&lt;&gt;&gt; q;</span><br><span class="line">    q.<span class="built_in">emplace</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">done</span><span class="params">(n)</span></span>;</span><br><span class="line">    i64 ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [d, x] = q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (done[x]) <span class="keyword">continue</span>;</span><br><span class="line">        done[x] = <span class="literal">true</span>;</span><br><span class="line">        ans += d;</span><br><span class="line">        ++ cnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [y, w] : adj[x]) &#123;</span><br><span class="line">            q.<span class="built_in">emplace</span>(w, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt == n) cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;orz\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="kruskal">Kruskal</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5010</span>, M = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DSU</span> &#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; f, siz;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">DSU</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">DSU</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">init</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        f.<span class="built_in">resize</span>(n);</span><br><span class="line">        std::<span class="built_in">iota</span>(f.<span class="built_in">begin</span>(), f.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        siz.<span class="built_in">assign</span>(n, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (x != f[x]) &#123;</span><br><span class="line">            x = f[x] = f[f[x]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">same</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(x) == <span class="built_in">find</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        x = <span class="built_in">find</span>(x);</span><br><span class="line">        y = <span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (x == y) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        siz[x] += siz[y];</span><br><span class="line">        f[y] = x;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> siz[<span class="built_in">find</span>(x)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> u, v, w;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>); cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n, m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">auto</span> dsu = <span class="built_in">DSU</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="function">vector&lt;Edge&gt; <span class="title">edge</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;++i) &#123;</span><br><span class="line">        cin &gt;&gt; edge[i].u &gt;&gt; edge[i].v &gt;&gt; edge[i].w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(edge.<span class="built_in">begin</span>(), edge.<span class="built_in">end</span>(), [](Edge &amp;a, Edge &amp;b) &#123; <span class="keyword">return</span> a.w &lt; b.w; &#125;);</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;++i) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [u, v, w] = edge[i];</span><br><span class="line">        <span class="keyword">if</span> (dsu.<span class="built_in">same</span>(u, v)) <span class="keyword">continue</span>;</span><br><span class="line">        ans += w;</span><br><span class="line">        dsu.<span class="built_in">merge</span>(u, v);</span><br><span class="line">        ++ cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt == n - <span class="number">1</span>) cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;orz\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
        <tag>模板</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>最短Hamilton距离</title>
    <url>/2025/01/23/00/35/23/</url>
    <content><![CDATA[<p>这题可以说是状态压缩的其中一类的板题了</p>
<span id="more"></span>
<h1 id="最短hamilton路径"><a
href="https://www.acwing.com/problem/content/description/93/">最短Hamilton路径</a></h1>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">21</span>;</span><br><span class="line"><span class="type">int</span> dis[N][N];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">1</span>&lt;&lt;N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>); cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j) &#123;</span><br><span class="line">            cin &gt;&gt; dis[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> s=<span class="number">1</span>;s&lt;(<span class="number">1</span>&lt;&lt;n);++s) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((s &gt;&gt; j) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>;k&lt;n;++k) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((s ^ (<span class="number">1</span> &lt;&lt; j)) &gt;&gt; k &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                        dp[s][j] = <span class="built_in">min</span>(dp[s][j], dp[s^(<span class="number">1</span> &lt;&lt; j)][k] + dis[k][j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>][n - <span class="number">1</span>] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title>算法竞赛中左闭右开区间的好处</title>
    <url>/2025/01/24/13/02/51/</url>
    <content><![CDATA[<p>左闭右开区间（[l, r)）在算法竞赛中常用，主要因为其计算长度直观（r -
l）、分割区间无重叠、与 STL 接口兼容、空区间表示自然（l ==
r），并且在循环和算法实现中逻辑更简洁。这些特点使得它成为处理区间问题的首选。</p>
<span id="more"></span>
<h1 id="左闭右开区间的好处">左闭右开区间的好处</h1>
<h2 id="区间长度计算更直观">1. 区间长度计算更直观</h2>
<p>左闭右开区间的长度可以简单地通过公式 <code>r - l</code>
计算，而不需要再加 1。例如：<br />
- 对于区间 [2, 5)，长度是 <code>5 - 2 = 3</code>，对应 2, 3, 4。<br />
- 如果使用左闭右闭区间 [2, 4]，计算长度则需要用公式
<code>r - l + 1</code>。</p>
<hr />
<h2 id="便于分割区间">2. 便于分割区间</h2>
<p>左闭右开区间在分割时不会产生重叠，容易维护。例如：<br />
- 区间 [l, m) 和 [m, r) 是严格不重叠的，起点 <code>m</code>
不会同时属于两个区间。<br />
- 若使用左闭右闭区间 [l, m] 和 [m + 1,
r]，则需要对区间端点进行额外处理。</p>
<hr />
<h2 id="与常用-stl-接口兼容">3. 与常用 STL 接口兼容</h2>
<p>在 C++ STL
中，大多数容器和算法的操作也是基于左闭右开区间设计的，例如：<br />
- <code>std::vector</code> 的 <code>begin()</code> 和
<code>end()</code>，<code>end()</code>
指向的是超出最后一个元素的下一个位置。<br />
- <code>std::lower_bound</code> 和 <code>std::upper_bound</code>
通常会返回左闭右开的范围。</p>
<p>这种统一的约定让代码更易于理解和维护。</p>
<hr />
<h2 id="边界处理更方便">4. 边界处理更方便</h2>
<p>当一个区间为空时，左闭右开区间自然满足
<code>l == r</code>，表示区间无效。而对于左闭右闭区间，可能需要特殊处理空区间的逻辑。<br />
例如：<br />
- [2, 2) 是一个空区间，不需要额外的条件判断。<br />
- 如果使用左闭右闭区间 [2, 1] 来表示空区间，就显得不直观。</p>
<hr />
<h2 id="适配数学和逻辑简洁性">5. 适配数学和逻辑简洁性</h2>
<p>在某些情况下，左闭右开区间更符合数学上的定义。例如：<br />
- 对于循环、二分查找等算法，条件如 <code>while (l &lt; r)</code> 或
<code>for (int i = l; i &lt; r; ++i)</code>
更加简洁，不需要额外处理边界。</p>
<hr />
<h2 id="总结">总结</h2>
<p><strong>左闭右开区间的主要优点是计算简洁、逻辑清晰、便于维护和分割，且能更好地与
STL 接口兼容。</strong><br />
这些特性使得左闭右开成为算法竞赛和工程开发中的首选方式。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>素数筛</title>
    <url>/2025/01/21/13/55/32/</url>
    <content><![CDATA[<p>常见的素数筛有两种，分别是埃氏筛和欧拉筛，在数据规模较大的场景中，欧拉筛的效率高于埃氏筛，但欧拉筛的编码相对较复杂，不过也挺简单。</p>
<span id="more"></span>
<h1 id="素数筛">素数筛</h1>
<h2 id="欧拉筛线性筛">欧拉筛（线性筛）</h2>
<p>这是最快的素数筛法（应该吧），时间复杂度能干到O(n)，其实基本步骤很好理解，这玩意唯一的难度就我而言应该是防止越界的判断，其他的我觉得到是非常好理解。</p>
<h3 id="步骤整理">步骤整理</h3>
<ol type="1">
<li>一个容器，用来存放筛选的质数</li>
<li>一个bool数组，用来判断一个数字是否被筛掉</li>
<li>函数内一层for循环包着，区间为 [2,n]
<ol type="1">
<li>循环内最先检查当前数字的状态（是否被筛掉），没有的话就是质数，把他压入容器</li>
<li>接下来跟着一个循环 （范围for），遍历质数的容器
<ol type="1">
<li>首先为了防止越界，先检查边界，如果大于 n ，就直接跳出循环</li>
<li>然后执行一次筛除操作，将容器的当前数和 索引 i
相乘得到的倍数筛掉（改bool）</li>
<li>如果当前的 i 是已经被筛掉的，此时跳出循环</li>
</ol></li>
</ol></li>
</ol>
<h3 id="模板">模板</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e8</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">bool</span> not_prime[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; prime;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sieve</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!not_prime[i]) &#123;</span><br><span class="line">            prime.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j: prime) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i*j&gt;n) <span class="keyword">break</span>;</span><br><span class="line">            not_prime[i*j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i%j==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="埃氏筛">埃氏筛</h2>
<h3 id="模板-1">模板</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sieve</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!not_prime[i]) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=n;++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i*j&gt;n) <span class="keyword">break</span>;</span><br><span class="line">                not_prime[i*j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>数论</tag>
        <tag>素数筛</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树模板及常见题型</title>
    <url>/2025/01/24/11/50/35/</url>
    <content><![CDATA[<p>这里包含了线段树的模板以及常见题型</p>
<span id="more"></span>
<h1 id="模板">模板</h1>
<h2 id="懒标记线段树">懒标记线段树</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="常见题型">常见题型</h1>
<h2 id="区间加-区间求和">区间加 + 区间求和</h2>
<p>例题：<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDMzNzI=">洛谷 P3372
【模板】线段树 1<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>逆序对</title>
    <url>/2025/01/21/10/17/08/</url>
    <content><![CDATA[<p>用树状数组很神奇的做出来了，原理暂时不清楚，反正就是很神奇</p>
<span id="more"></span>
<h1 id="代码">代码</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x &amp; (-x))</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line">i64 tree[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x &lt; N) &#123;</span><br><span class="line">        tree[x] += d;</span><br><span class="line">        x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">i64 <span class="title">sum</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    i64 res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        res += tree[x];</span><br><span class="line">        x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>); cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">a</span>(n<span class="number">+1</span>);</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        cin &gt;&gt; a[i].first;</span><br><span class="line">        a[i].second = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">        b[a[i].second] = i;</span><br><span class="line">        <span class="keyword">if</span> (a[i].first == a[i<span class="number">-1</span>].first) &#123;</span><br><span class="line">            b[a[i].second] = b[a[i<span class="number">-1</span>].second];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    i64 ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;--i) &#123;</span><br><span class="line">        <span class="built_in">update</span>(b[i], <span class="number">1</span>);</span><br><span class="line">        ans += <span class="built_in">sum</span>(b[i] - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>给 neovim 加上 DeepSeek AI 助手来高效编辑代码</title>
    <url>/2025/01/27/13/27/03/</url>
    <content><![CDATA[<p>最近出的 <span class="exturl" data-url="aHR0cHM6Ly9jaGF0LmRlZXBzZWVrLmNvbS8=">DeepSeek<i class="fa fa-external-link-alt"></i></span>
我也小试了一下，确实挺好用的，关键是 API 真的便宜，刚好我也老早就想在
Neovim 里接入一个 AI ，现在正是实现的好时机</p>
<span id="more"></span>
<h1 id="注册-deepseek">注册 deepseek</h1>
<p>这一步没什么好说的，注册就完了</p>
<h1 id="给-neovim-添加-avanate-插件">给 neovim 添加 <a
href="https://github.com/yetone/avante.nvim">avanate</a> 插件</h1>
<blockquote>
<p>avante.nvim 是一个 Neovim 插件，旨在模拟 Cursor AI IDE 的行为。
它为用户提供人工智能驱动的代码建议，并能以最小的代价将这些建议直接应用到源文件中。</p>
</blockquote>
<p>简而言之，就是为 neovim 提供了接入各种 ai
的接口，这里我们可以直接用一下代码来安装</p>
<p><strong>注意</strong>：这里只提供 Lazy
插件管理器的安装方式，其他方式请自行设置。并且同为 Lazy
插件管理器也可能因为插件组织方式不同有所差异，以下为单文件插件管理方式</p>
<p>在 neovim 配置目录下对应的 plugins 目录下新建 avante.lua
文件，加入以下内容，保存重启即可自动安装</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;yetone/avante.nvim&quot;</span>,</span><br><span class="line">        event = <span class="string">&quot;VeryLazy&quot;</span>,</span><br><span class="line">        lazy = <span class="literal">false</span>,</span><br><span class="line">        version = <span class="literal">false</span>, <span class="comment">-- set this if you want to always pull the latest change</span></span><br><span class="line">        opts = &#123;</span><br><span class="line">            provider = <span class="string">&quot;openai&quot;</span>,</span><br><span class="line">            auto_suggestions_provider = <span class="string">&quot;openai&quot;</span>, <span class="comment">-- Since auto-suggestions are a high-frequency operation and therefore expensive, it is recommended to specify an inexpensive provider or even a free provider: copilot</span></span><br><span class="line">            openai = &#123;</span><br><span class="line">                endpoint = <span class="string">&quot;https://api.deepseek.com&quot;</span>,</span><br><span class="line">                model = <span class="string">&quot;deepseek-chat&quot;</span>,</span><br><span class="line">                timeout = <span class="number">30000</span>, <span class="comment">-- Timeout in milliseconds</span></span><br><span class="line">                temperature = <span class="number">0</span>,</span><br><span class="line">                max_tokens = <span class="number">4096</span>,</span><br><span class="line">                <span class="comment">-- optional</span></span><br><span class="line">                api_key_name = <span class="string">&quot;DEEPSEEK_API_KEY&quot;</span>, <span class="comment">-- default OPENAI_API_KEY if not set</span></span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">-- if you want to build from source then do `make BUILD_FROM_SOURCE=true`</span></span><br><span class="line">        build = <span class="string">&quot;make&quot;</span>,</span><br><span class="line">        <span class="comment">-- build = &quot;powershell -ExecutionPolicy Bypass -File Build.ps1 -BuildFromSource false&quot; -- for windows</span></span><br><span class="line">        dependencies = &#123;</span><br><span class="line">            <span class="string">&quot;nvim-treesitter/nvim-treesitter&quot;</span>,</span><br><span class="line">            <span class="string">&quot;stevearc/dressing.nvim&quot;</span>,</span><br><span class="line">            <span class="string">&quot;nvim-lua/plenary.nvim&quot;</span>,</span><br><span class="line">            <span class="string">&quot;MunifTanjim/nui.nvim&quot;</span>,</span><br><span class="line">            <span class="comment">--- The below dependencies are optional,</span></span><br><span class="line">            <span class="string">&quot;nvim-tree/nvim-web-devicons&quot;</span>, <span class="comment">-- or echasnovski/mini.icons</span></span><br><span class="line">            <span class="string">&quot;hrsh7th/nvim-cmp&quot;</span>,            <span class="comment">-- autocompletion for avante commands and mentions</span></span><br><span class="line">            <span class="string">&quot;zbirenbaum/copilot.lua&quot;</span>,      <span class="comment">-- for providers=&#x27;copilot&#x27;</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">-- support for image pasting</span></span><br><span class="line">                <span class="string">&quot;HakonHarnes/img-clip.nvim&quot;</span>,</span><br><span class="line">                event = <span class="string">&quot;VeryLazy&quot;</span>,</span><br><span class="line">                opts = &#123;</span><br><span class="line">                    <span class="comment">-- recommended settings</span></span><br><span class="line">                    default = &#123;</span><br><span class="line">                        embed_image_as_base64 = <span class="literal">false</span>,</span><br><span class="line">                        prompt_for_file_name = <span class="literal">false</span>,</span><br><span class="line">                        drag_and_drop = &#123;</span><br><span class="line">                            insert_mode = <span class="literal">true</span>,</span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="comment">-- required for Windows users</span></span><br><span class="line">                        use_absolute_path = <span class="literal">true</span>,</span><br><span class="line">                    &#125;,</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">-- Make sure to set this up properly if you have lazy=true</span></span><br><span class="line">                <span class="string">&#x27;MeanderingProgrammer/render-markdown.nvim&#x27;</span>,</span><br><span class="line">                opts = &#123;</span><br><span class="line">                    file_types = &#123; <span class="string">&quot;markdown&quot;</span>, <span class="string">&quot;Avante&quot;</span> &#125;,</span><br><span class="line">                &#125;,</span><br><span class="line">                ft = &#123; <span class="string">&quot;markdown&quot;</span>, <span class="string">&quot;Avante&quot;</span> &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="设置-api_key">设置 API_KEY</h1>
<h2 id="获取-api_key">获取 API_KEY</h2>
<p>前往 <span class="exturl" data-url="aHR0cHM6Ly9wbGF0Zm9ybS5kZWVwc2Vlay5jb20vYXBpX2tleXM=">deepseek
开放平台<i class="fa fa-external-link-alt"></i></span> 登陆自己账号。初始用户会有 10￥ 的赠送额度，点击创建API key
即可，生成 api key 后请妥善保存，退出后就无法重新查看</p>
<h2 id="设置系统变量">设置系统变量</h2>
<p>不设置系统变量的情况下，每次重新进入 neovim 调用 avanate
都要重新输入一遍 API KEY，设置后即可自动获取。</p>
<h3 id="windows-系统">windows 系统</h3>
<p>直接进入系统环境变量设置窗口，添加变量 <code>DEEPSEEK_API_KEY</code>
，设置值为刚刚创建的 api key</p>
<h3 id="linux-系统">linux 系统</h3>
<p>编辑 <code>/etc/environment</code> 文件，加入
<code>DEEPSEEK_API_KEY='api_key</code> ，等号后面的 <code>api_key</code>
替换为刚刚创建的 api key ，随后保存重启系统即可</p>
<h1 id="使用">使用</h1>
<p><strong><code>&lt;leader&gt;</code>
键是自定义的，一般情况下是空格键</strong></p>
<ul>
<li>进入 neovim 后，按下 <code>&lt;leader&gt;aa</code>
即可打开对话窗口</li>
</ul>
<p>其余更多使用方式请查阅 <a
href="https://github.com/yetone/avante.nvim">avante 官方仓库</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>neovim</tag>
        <tag>deepseek</tag>
      </tags>
  </entry>
</search>
